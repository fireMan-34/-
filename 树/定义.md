树是 n (n >= 0) 个节点的有限集，当 n 为 0 时成为空数，在任意非空树中应满足：
  1. 有且仅有一个特定的成为根的节点。
  2. 当 n > 1 时，其余节点但可分为 m (m > 0) 个互不相交的有限集 T1，T2 …… Tm，其中每个集合本身又是一颗树，并且成为根的字数。

显然树的定义是递归的，即在树的定义中又用到了自身，树是一种递归的数据结构。树作为一种逻辑数据结构，同时也是一种分层结构。具有以下两个特点。

  1. 树的根节点没有前驱，除根节点外所有节点有且只有一个前驱。

  知识扩展
    在树的结构中，“前驱节点”特指当前节点的父节点，这是基于树的父子关系定义的。而在遍历算法中，比如二叉树的中序遍历过程中，确实存在一个相对意义上的“前驱节点”，它是指在遍历序列中位于当前节点之前被访问到的那个节点。

    对于树本身的结构而言：
    
    根节点没有父节点，因此也就没有前驱节点。
    其他每个节点都有且仅有一个父节点，这个父节点就是它的前驱节点。
    而在遍历序列中的“前驱节点”含义是动态变化的，取决于具体的遍历过程和顺序。
    2. 树中的所有节点都可有零到多个后继节点。

## 基本术语

高度为 4

第一层节点 a

第二层节点 a(b ,c ,d)

第三层节点 b(e,f) c(g), d(h,i,j)

第四层节点 e(k,l) h(m)

1. 考虑节点 K ，从根节点 A 到 节点 K 的唯一路径上的任意节点称为，K 的祖先，如节点 B 是节点 K 的祖先，而节点 K 是节点B 的子孙，路径上最接近节点 K 的节点 E 称为 K 的双亲，而节点 K 为 节点 E 的孩子节点，而节点 K 为节点 E 的孩子。根节点 A 是树中唯一没有双亲的节点。有相同双亲节点的节点成为兄弟节点，如节点 K 和 节点 L 有相同的双亲节点，即 K 和 L 互为兄弟。
2. 树中的一个节点的孩子个数成为该**节点的度**，树种节点种最大的度数成为**树的度数**，如节点 B 的度为 2， D 为 3， 树的节点为 3。
3. 度大于 0 的节点为**分支节点**（又称非终端节点），度为 0 的节点被成为**叶子节点**，在每个分支节点中，每个节点的分支数就是该节点的度。
4. 节点的深度、高度和层次。
   1. **节点层次**从树根开始定义，树节点为第一层，它的子节点成为第2层，以此类推。双亲在同一层节点互为堂兄弟，图中节点 G 与 F、H、I、J 互为堂兄弟。
   2. **节点深度**从根节点开始自顶向下逐层累加到当前节点的边数
   3. **节点高度**从当前节点到最远叶子节点的所累加的边数
   4.  **树节高度（深度）** 是树节点中节点最大的层数，图中未树的高度 5
5.  有序树和无序树，如果树的节点中各子树都是有序的不能互换，称该树为有序树，否则称为无序树。
6. **路径**和**路径长度**，树中两个节点之间的 **路径**是由两个节点之间所经过的节点序列所构成的，而 **路径长度**是路径上所经过的边的个数,注意由于树的分支是有向的,即从双亲指向孩子,所以树中所有路径的是从上向下的,同一双亲的两个孩子之间不存在路径.
7. **森林** ,是 m (m > 0)  棵互不相交的树的集合,森林的概念和树的概念十分相近,因为只要把树的节点删去就变成森林,反之在给 m 棵独立的树添加一个节点,并且把这 m 棵树作为该节点的子树,则森林就变成树.



## 树的性质(数学含量高)

1. 树中的节点树等于所有节点的度 + 1

2. 度为 m 的树中第 i 层至多有 
   $$
   m^(i-1)(i >= 1)
   $$
   个节点 ??? 不太理解,需要重新看一遍树的度,大概就能开始推导

3. 高度为 h 的 m 叉树之多有个
   $$
   (m^h - 1) / (m - 1)
   $$
    个节点

4. 具有 n 个节点的 m 叉树最小高度 
   $$
   [\log_m(n(m-1) + 1)]
   $$
   

## 树的存储结构

以如下树为例子

第一层
$$
A(B,C)
$$
第二层
$$
B(D), C(E,F)
$$
第三层
$$
D(G,H,I),E(J)
$$

### 双亲表示法

我们假设以一连续空间存储树的节点,同时每个节点中,附设一个指示器指示器双亲节点到链表中的位置,也就是说,每个节点除了知道自己是谁,还知道它的双亲节点在哪里.

| data | parent |
| :--: | :----: |

其中 `data` 是数据域, `parent` 是指针域.存储该节点在数组中的节点下表

```javascript
const yingpangList = [
    [ -1, { data: 33, } ],
    [ 0, { data: 22,  } ],
    [ 1, { data: 88 } ],
    [ 0, { data: 66 } ]
];
```

```c#
/** 双亲表示法  */
#define MAX_TREE_SIZE 100
typedef int TElemType; // 树节点的数据类型,目前定义为整型
/** 节点结构 */
typedef struct PTNode(
	TElemType data; // 数据结构
    int parent; // 双亲位置
)PTNode;
/** 树结构 */
typedef struct PTree(
	PTNode nodes[MAX_TREE_SIZE];
    int r, n;
)
```

这样的存储结构,我们可以根据节点 `parent`  的指针找到它的双亲节点,所用的时间复杂度为 O(1), 知道 `parent`  为 -1 的时候,表示找到了树的根节点,可如果要找到节点的孩子,拿对不去,请遍历整个结构.

### 孩子表示法

具体办法是,把每个节点孩子节点排列起来,以单链表作为存储结构,如果是叶子节点则表此节单链表为空,然后 n 个头指针又组成线性表.

为此设计了两种节点数据结构,一个是孩子链表的孩子节点

| child | next |
| ----- | ---- |

其中 `child` 是数据域, 用来存储某个节点表头数据中的下标,`next` 是指针域,用来存储指向某节点的下个孩子节点的指针.

另一个是表头数组的表头节点.

| data | first_Child |
| ---- | ----------- |

其中 `data` 是数据域,村粗某节点的数据信息,firstChild 是头指针域, 存储该节点的孩子链表头指针.

```c#
/** 孩子表示法 */
/*** 孩子结构 */
typedef struct CTNode(
int child;
struct CTNode *next
)ChildPtr;

typedef struct(
	TElemType data;
    ChildPtr firstChild;
)CTBox;

typedef struct (
	CTBox nodes[MAX_TREE_SIZE]; 节点数组
    int r, n;// 根位置,和节点数
)
```

### 孩子兄弟表示法

刚才我们分别从双亲角度和从孩子的角度研究树的存储结构,如果我们从树节点的兄弟的角度又如何,对于树的层级结构来说,之研究节点的兄弟是不行,我们观察后发现,任意一棵树他的节点的第一个孩子如果存在就是唯一的,他的右节点存在也是唯一的.因此我们设置两个指针,分别指向该节点的第一个孩子和此节点的右兄弟.

| data | first_child | right_sib |
| ---- | ----------- | --------- |

其中 `data` 代表数据域 , first Child 为指针域,指向该节点第一个孩子节点的存储地址, `rightsib` 是指针域,存储右兄弟的存储地址.

```c#
typedef struct CSNode (
	TElement type data;
    struct CSNode *firstChild, * rightsib;
) CSNode, *CSTree;
```

这不就是二叉树吗? 没错其实这个表示法就是把一颗复杂的树变成一颗二叉树.